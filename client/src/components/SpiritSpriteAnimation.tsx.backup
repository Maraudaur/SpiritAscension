import { useEffect, useRef } from "react";
import { getBaseSpirit } from "@/lib/spiritUtils";

// --- REMOVED 'import * as PIXI' ---
// --- ADDED ALL MODULAR IMPORTS ---
import { Application } from "@pixi/app";
import { Sprite } from "@pixi/sprite"; // <-- We just need Sprite from here
import { AnimatedSprite } from "@pixi/sprite-animated"; // <-- Import AnimatedSprite
import { Texture, Rectangle } from "@pixi/core"; // <-- Import Textu
import { Assets } from "@pixi/assets";
import { Graphics } from "@pixi/graphics";
import { PixelateFilter } from "@pixi/filter-pixelate";
import type { TickerCallback } from "@pixi/ticker";

interface SpiritSpriteAnimationProps {
  spiritId: string;
  position: "left" | "right";
  size?: number;
  isTakingDamage: boolean;
  isDefeated: boolean;
}

export function SpiritSpriteAnimation({
  spiritId,
  position,
  size = 256,
  isTakingDamage,
  isDefeated,
}: SpiritSpriteAnimationProps) {
  const canvasRef = useRef<HTMLDivElement>(null);
  const appRef = useRef<Application | null>(null); // Use 'Application' type
  const spriteRef = useRef<AnimatedSprite | null>(null); // Use 'AnimatedSprite' type
  const originalXRef = useRef<number>(0);
  const tickersRef = useRef<Set<TickerCallback<any>>>(new Set()); // Use 'TickerCallback' type

  // Helper to safely add and track tickers
  const addTicker = (fn: TickerCallback<any>) => {
    if (appRef.current) {
      tickersRef.current.add(fn);
      appRef.current.ticker.add(fn);
    }
  };

  // Helper to safely remove and untrack tickers
  const removeTicker = (fn: TickerCallback<any>) => {
    if (appRef.current) {
      tickersRef.current.delete(fn);
      appRef.current.ticker.remove(fn);
    }
  };

  // --- Main PIXI Setup Effect ---
  useEffect(() => {
    if (!canvasRef.current) return;

    const spiritData = getBaseSpirit(spiritId);
    if (!spiritData || !spiritData.spriteConfig) {
      console.error(`SpiritSpriteAnimation: No spriteConfig for ${spiritId}`);
      return;
    }

    const { textureUrl, frameWidth, frameHeight, totalFrames, animationSpeed } =
      spiritData.spriteConfig;

    let app: Application;

    const initPixi = async () => {
      try {
        app = new Application({
          width: size,
          height: size,
          backgroundColor: 0x000000,
          backgroundAlpha: 0,
          antialias: true,
        });

        if (!canvasRef.current) return;

        canvasRef.current.appendChild(app.view as HTMLCanvasElement);
        appRef.current = app;

        const texture = await Assets.load(textureUrl); // Use modular 'Assets'
        const frames: Texture[] = []; // Use modular 'Texture'
        for (let i = 0; i < totalFrames; i++) {
          // The v7 way: new Texture(baseTexture, frameRectangle)
          const frameTexture = new Texture(
            texture.baseTexture, // 1. The BaseTexture
            new Rectangle(i * frameWidth, 0, frameWidth, frameHeight), // 2. The frame
          );
          frames.push(frameTexture);
        }

        const animatedSprite = new AnimatedSprite(frames); // Use modular 'AnimatedSprite'
        animatedSprite.animationSpeed = animationSpeed;
        animatedSprite.play();
        animatedSprite.anchor.set(0.5);
        animatedSprite.x = size / 2;
        animatedSprite.y = size / 2;
        const scale = size / frameWidth;
        animatedSprite.scale.set(scale);
        if (position === "right") {
          animatedSprite.scale.x *= -1;
        }

        app.stage.addChild(animatedSprite);
        spriteRef.current = animatedSprite;
        originalXRef.current = animatedSprite.x;

        // --- SUMMON VFX ---
        const flash = new Graphics(); // Use modular 'Graphics'
        flash.beginFill(0xffffff); // <-- Use beginFill()
        flash.drawCircle(0, 0, size / 2);
        flash.endFill(); // <-- Add endFill()
        flash.x = size / 2;
        flash.y = size / 2;
        flash.scale.set(0);
        flash.alpha = 0.8;
        app.stage.addChild(flash);

        let elapsed = 0;
        const duration = 300; // 0.3 seconds

        const spawnTicker: TickerCallback<any> = (delta) => {
          elapsed += app.ticker.elapsedMS;
          const progress = Math.min(elapsed / duration, 1);
          const easedProgress = 1 - Math.pow(1 - progress, 3); // easeOutCubic

          flash.scale.set(easedProgress * 1.5); // Scale up
          flash.alpha = 1 - easedProgress; // Fade out

          if (progress === 1) {
            removeTicker(spawnTicker);
            flash.destroy();
          }
        };
        addTicker(spawnTicker);
      } catch (error) {
        console.error(
          "SpiritSpriteAnimation: Error initializing PixiJS:",
          error,
        );
      }
    };

    initPixi();

    return () => {
      // Full cleanup
      if (appRef.current) {
        tickersRef.current.forEach((ticker) => {
          appRef.current?.ticker.remove(ticker);
        });
        tickersRef.current.clear();
        appRef.current.destroy(true, { children: true });
        appRef.current = null;
      }
      spriteRef.current = null;
      originalXRef.current = 0;
    };
  }, [spiritId, position, size]);

  // --- Damage Effect (Shake/Flash) ---
  useEffect(() => {
    if (isTakingDamage && spriteRef.current && !isDefeated) {
      const sprite = spriteRef.current;
      const timeouts: NodeJS.Timeout[] = [];

      sprite.tint = 0xff0000; // Red flash

      const shakeTimeline = [
        { dx: -6, delay: 0 },
        { dx: 6, delay: 80 },
        { dx: -6, delay: 160 },
        { dx: 6, delay: 240 },
        { dx: 0, delay: 320 },
      ];

      shakeTimeline.forEach(({ dx, delay }) => {
        const timeoutId = setTimeout(() => {
          if (spriteRef.current) {
            spriteRef.current.x = originalXRef.current + dx;
          }
        }, delay);
        timeouts.push(timeoutId);
      });

      const resetTimeout = setTimeout(() => {
        if (spriteRef.current) {
          spriteRef.current.tint = 0xffffff; // Reset tint
        }
      }, 400);
      timeouts.push(resetTimeout);

      return () => {
        timeouts.forEach(clearTimeout);
      };
    }
  }, [isTakingDamage, isDefeated]);

  // --- DEFEAT VFX (Dissolve) ---
  useEffect(() => {
    if (isDefeated && spriteRef.current && appRef.current) {
      const sprite = spriteRef.current;
      const app = appRef.current;

      tickersRef.current.forEach((ticker) => {
        app.ticker.remove(ticker);
      });
      tickersRef.current.clear();

      const filter = new PixelateFilter(1); // Use modular 'PixelateFilter'
      sprite.filters = [filter]; // This will now be compatible

      let elapsed = 0;
      const duration = 1000; // 1 second dissolve

      const defeatTicker: TickerCallback<any> = (delta) => {
        elapsed += app.ticker.elapsedMS;
        const progress = Math.min(elapsed / duration, 1);

        filter.size = 1 + progress * 19;
        sprite.alpha = 1 - progress;

        if (progress === 1) {
          removeTicker(defeatTicker);
          sprite.visible = false;
        }
      };

      addTicker(defeatTicker);

      return () => {
        removeTicker(defeatTicker);
      };
    }
  }, [isDefeated]);

  return (
    <div
      ref={canvasRef}
      style={{
        width: `${size}px`,
        height: `${size}px`,
        position: "relative",
        pointerEvents: "none",
      }}
    />
  );
}
